
'use client';

import { useState, useCallback, memo, useEffect, useMemo } from 'react';
import type { Chat, Message } from '@/lib/types';
import { generateChatTitle } from '@/app/actions';
import { useToast } from '@/hooks/use-toast';
import ChatMessages from './chat-messages';
import ChatInput from './chat-input';
import { useIsMobile } from '@/hooks/use-mobile';
import { SidebarTrigger } from '@/components/ui/sidebar';
import { useAuth, useCollection, useFirestore } from '@/firebase';
import { collection, query, orderBy, Timestamp, doc, getDoc, setDoc, serverTimestamp } from 'firebase/firestore';
import { updatePsychologicalBlueprint } from '@/ai/flows/update-psychological-blueprint';
import { v4 as uuidv4 } from 'uuid';
import { errorEmitter } from '@/firebase/error-emitter';
import { FirestorePermissionError } from '@/firebase/errors';
import type { SecurityRuleContext } from '@/firebase/errors';


interface ChatPanelProps {
  chat: Chat;
  appendMessage: (chatId: string, message: Omit<Message, 'id'>) => Promise<void>;
  updateChatTitle: (chatId: string, title: string) => Promise<void>;
}

function ChatPanel({ chat, appendMessage, updateChatTitle }: ChatPanelProps) {
  const [isResponding, setIsResponding] = useState(false);
  const { toast } = useToast();
  const isMobile = useIsMobile();
  const { user } = useAuth();
  const firestore = useFirestore();

  const messagesQuery = useMemo(
    () =>
      user?.uid && firestore && chat.id
        ? query(
            collection(firestore, `users/${user.uid}/chats/${chat.id}/messages`),
            orderBy('timestamp', 'asc')
          )
        : undefined,
    [user?.uid, firestore, chat.id]
  );
  
  const { data: remoteMessages, loading: messagesLoading } = useCollection<Message>(messagesQuery);
  const [localMessages, setLocalMessages] = useState<Message[]>([]);

  useEffect(() => {
    if (remoteMessages) {
        setLocalMessages(remoteMessages);
    }
  }, [remoteMessages]);


  const triggerBlueprintUpdate = useCallback(async (currentMessages: Message[]) => {
      if (!user) return;

      const stateDocRef = doc(firestore, `users/${user.uid}/chatbotState/main`);
      try {
        const previousStateSnap = await getDoc(stateDocRef);
        const previousBlueprint = previousStateSnap.exists()
            ? JSON.stringify(previousStateSnap.data().blueprint, null, 2)
            : "No previous state. This is my first reflection.";

        const fullChatHistory = currentMessages.map(msg => {
            const date = msg.timestamp && typeof (msg.timestamp as any).toDate === 'function' 
              ? (msg.timestamp as Timestamp).toDate() 
              : new Date();
            return `[${date.toISOString()}] ${msg.role}: ${msg.content}`;
          }).join('\n');
        
        const newBlueprint = await updatePsychologicalBlueprint({
            fullChatHistory,
            previousBlueprint,
        });

        const dataToSave = {
            blueprint: newBlueprint,
            updatedAt: serverTimestamp(),
        };
        await setDoc(stateDocRef, dataToSave);

      } catch (error: any) {
         if (error.code === 'permission-denied') {
            const permissionError = new FirestorePermissionError({
              path: stateDocRef.path,
              operation: 'write',
              requestResourceData: { blueprint: 'Generated by AI', updatedAt: 'Server Timestamp'}
            } satisfies SecurityRuleContext);
            errorEmitter.emit('permission-error', permissionError);
         } else {
             console.error("Error updating blueprint:", error);
         }
      }
  }, [user, firestore]);

  const getAIResponseAndUpdate = useCallback(async (currentMessages: Message[]) => {
    if (!user) return;
    setIsResponding(true);

    const plainHistory = currentMessages.map(msg => ({
      role: msg.role as 'user' | 'assistant',
      content: msg.content,
    }));

    const aiMessageId = uuidv4();
    let fullResponse = '';

    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          history: plainHistory,
          userId: user.uid,
        }),
      });

      if (!response.body) {
        throw new Error('La respuesta del servidor no contiene un cuerpo.');
      }
      
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let done = false;

      // Add the empty assistant message shell to start streaming into
      const assistantMessage: Message = {
        id: aiMessageId,
        role: 'assistant',
        content: '',
        timestamp: Timestamp.now(),
      };
      setLocalMessages(prev => [...prev, assistantMessage]);

      while (!done) {
        const { value, done: readerDone } = await reader.read();
        done = readerDone;
        const chunk = decoder.decode(value, { stream: true });
        fullResponse += chunk;
        
        // Update the content of the last message (the AI's)
        setLocalMessages(prev =>
          prev.map(msg =>
            msg.id === aiMessageId ? { ...msg, content: fullResponse } : msg
          )
        );
      }
      
    } catch (error) {
        console.error("Error procesando la respuesta de la IA:", error);
        toast({
          variant: "destructive",
          title: "Error",
          description: "No se pudo obtener una respuesta de la IA. Por favor, inténtalo de nuevo.",
        });
        // Remove the empty assistant message if an error occurred
        setLocalMessages(prev => prev.filter(msg => msg.id !== aiMessageId));
        setIsResponding(false);
        return; // Stop execution on error
    }

    setIsResponding(false);
    
    // Once streaming is complete, save the full message to Firestore
    const finalAiMessage: Omit<Message, 'id'> = {
      role: 'assistant',
      content: fullResponse,
      timestamp: Timestamp.now(),
    };
    await appendMessage(chat.id, finalAiMessage);

    // After-streaming logic
    if (currentMessages.length === 1) {
      const userMessage = currentMessages[0];
      const conversationForTitle = `User: ${userMessage.content}\nAssistant: ${fullResponse}`;
      const newTitle = await generateChatTitle(conversationForTitle);
      await updateChatTitle(chat.id, newTitle);
    }
    
    const updatedMessages = [...currentMessages, { ...finalAiMessage, id: aiMessageId }];
    if (updatedMessages.length % 5 === 0) {
      triggerBlueprintUpdate(updatedMessages);
    }

  }, [user, chat.id, appendMessage, updateChatTitle, toast, triggerBlueprintUpdate]);


  const handleSendMessage = useCallback(async (input: string, imageUrl?: string) => {
    if ((!input || !input.trim()) && !imageUrl) return;
    if (!user) {
        toast({
            variant: "destructive",
            title: "Error",
            description: "Debes iniciar sesión para chatear.",
        });
        return;
    }

    const userMessage: Message = {
      id: uuidv4(),
      role: 'user',
      content: input,
      timestamp: Timestamp.now(),
      ...(imageUrl && { imageUrl }),
    };

    const newMessages = [...localMessages, userMessage];
    setLocalMessages(newMessages); // Optimistic UI update
    await appendMessage(chat.id, userMessage);
    await getAIResponseAndUpdate(newMessages);

  }, [user, localMessages, appendMessage, chat.id, getAIResponseAndUpdate, toast]);

  // Effect to handle the very first response in a new chat
  useEffect(() => {
    // Only trigger if we have exactly one message and it's from the user
    if (localMessages.length === 1 && localMessages[0].role === 'user' && !isResponding) {
      // Check if this message has already been processed by looking at remote messages
      const remoteMessageExists = remoteMessages?.some(m => m.id === localMessages[0].id && m.role === 'user');
      const isNewChatJustCreated = remoteMessages?.length === 1 && remoteMessages[0].id === localMessages[0].id;

      if (isNewChatJustCreated) {
         getAIResponseAndUpdate(localMessages);
      }
    }
  }, [localMessages, remoteMessages, isResponding, getAIResponseAndUpdate]);


  return (
    <div className="flex flex-col h-full">
       <header className="flex h-14 items-center justify-between p-2 md:p-4 border-b">
        <div className="flex items-center gap-2">
          {isMobile && <SidebarTrigger />}
           <h2 className="text-base md:text-lg font-semibold truncate">
            {chat.title}
          </h2>
        </div>
      </header>
      <div className="flex-1 overflow-y-auto">
        <ChatMessages messages={localMessages} isResponding={isResponding || messagesLoading} />
      </div>
      <div className="mt-auto px-2 py-4 md:px-4 md:py-4 border-t bg-background/95 backdrop-blur-sm">
        <ChatInput
          onSendMessage={handleSendMessage}
          isLoading={isResponding || messagesLoading}
          chatHistory={localMessages}
        />
      </div>
    </div>
  );
}

export default memo(ChatPanel);
